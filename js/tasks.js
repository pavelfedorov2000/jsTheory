'use strict';

// 1
let x = 5;
alert(x++); // это постфиксная форма инкремента.Сначала возвращается исходное значение (5), а уже потом выполняется действие. Префиксная форма сразу бы вывела нам нужный результат (6, т.е. 5,увеличенное на 1)
alert(x); // Если добавить эту строку, то будет 6
// Ответ: 5

// 2
console.log([] + false - null + true);
// Разобьем задачу на этапы:
// 1
console.log([] + false); // "false". Пустой массив всегда превращается в пустую строку! А если мы что-то складываем со строкой, то все превращается в строку.
// 2
console.log([] + false - null); // Мы пытаемся из строки вычесть ничего, такой математической операции нет, поэтому будет NaN
console.log([] + false - null + true); // Мы к NaN добавляем true как бы подтверждая что будет Nan
// Ответ: Nan.

// 3
let y = 1;
    x = y = 2; // Читаем справа налево!
alert(x);
// Ответ: 2

//4
console.log([] + 1 + 2); // "12"
// Действия:
// 1) [] = "" // Пустой массив всегда превращается в пустую строку!
// 2) "" + 1 = "1"
// 3) "1" + 2 = "12"
// Ответ: "12"

// 5
alert("1"[0]); // В квадратных скобках указан индекс (порядковый номер) первого элемента строки. А т.к. там всего один элемент, то он и выведется в модальном окне.
// Ответ: 1

// 6
console.log(2 && 1 && null && 0 && undefined); // null
// Действия
// 1)
console.log(2 && 1); // true
// 2
console.log(2 && 1 && null); // тут null - это false, поэтому оператор и запинается и возвращает null
// Оператор "и" && запинается на правде, а "или" || на лжи. И в том месте где оператор "запнулся" он прекращает свою работу.
//Ответ: null

// 7
console.log(!!(a && b)); // !! превращает любой тип данных в булиновый
console.log(a && b); // это же не булиновый тип данных
// Ответ: разница между двумя выражениями есть

// 8
alert(null || 2 && 3 || 4);
// Действия:
// 1)
alert(null || 2); // 2 - true, null - false, это оператор или, а значит если хотя бы одно значение true он срабатывает и возвращает 2.
// 2)
alert(2 && 3); // оба true, значит оператор срабатывает
// 3)
alert(3 || 4); // оператор или запинается на первой правде
// Ответ: 3

// 9
a = [1,2,3];
b= [1,2,3];
a == b ?
// Даже несмотря на то, что данные в массивах совпадают, все равно это абсолютно разные массивы!

// 10
alert(+"Infinity"); // Изначально у нас просто строка "Infinity", которую с помощью унарного плюса мы превращаем в тип данных число
// Ответ: Infinity

// 11
console.log("ёжик" > "яблоко"); // по правилам юникода ё идет после я

// 12
console.log(0 || '' || 2 || undefined || true || false); // первые два значения false, а 2 true, на нем-то оператор или и запнется и выведет в консоль 2.
// Ответ: 2
